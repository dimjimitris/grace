No more 'a node things. Everything that needs 'loc' has a field 'loc' inside it.
No more goofy nested types. var x char[1][2] will be typ: char; dims: [Some 1; Some 2]


var_def needs:
- id
- data_type
- frame_offset
- frame type it belongs to (Llvm.lltype) (nope)
- internal_id of function it belongs to (might be useful)

param_def needs:
- id
- data_type
- pass_by
- frame_offset
- frame type it belongs to (Llvm.lltype) (nope)
- internal_id of function it belongs to (might be useful)

l_value needs:
- LString is ok
- ArrayAccess changes (no more nesting shit)
- Id changes and needs:
    - name (id)
    - data_type
    - pass_by
    - frame_offset
    - frame type it belongs to (nope)
    - internal_id of function it belongs to?
    - maybe just have Id contain a var_def or param_def

func_call needs:
- id
- internal_id of callee
- internal_id of caller
- list of arguments
- return type

argument is a new type and it needs:
- pass_by
- if pass_by is Reference then we store the LValue it refers to (not the expression)
- if pass_by is Value then we store the expression as is

expr seems alright...

block and stmt seems alright...

local_def seems fine...

func_decl and func_def should become one type.
They have:
- id
- internal_id
- param_def list
- return type
- local_def list
- block node option
- is declared/defined

Now, it will be a good idea to reorganize list of local defs so that all variable
definitions are at the top and all function decls/defs are at the bottom.

e.g.

fun main(): nothing
  var f: int;
  fun aux(a: int): nothing
    fun aux_inner(ref b: int): nothing
    {
        b <- b + a; $ use parameter a
    }
  {
    aux_inner(f); $ use variable f
  }
  var x, z : char;
  var mlton : int;
{
  aux(1); $ wah
}

definitions will appear in order:
- f
- x
- z
- mlton
- aux
  - aux_inner

and internal_id will be:

main: ["main"]
aux:  ["aux"; "main"]
aux_inner: ["aux_inner"; "aux"; "main"]

These functions will be defined in llvm code as such:

func_main
func_main_aux
func_main_aux_aux_inner

And their frame types will be named:
frame_main
frame_main_aux
frame_main_aux_aux_inner

So we can find the frame type of a function if we know its internal_id. (So keeping frame type information might not be usefull)
Also and very importantly! If we use the tail of internal_id we can find the
frame of the parent function.
And the length of this list gives us the nesting depth.

!!! There is some data duplication above, but it would be too tedius to constantly do lookups and
keep hashtables for every little shit we need!!!